package dk.sdu.mmmi.mdsd.generator;

import com.google.common.collect.Iterators;
import dk.sdu.mmmi.mdsd.math.Args;
import dk.sdu.mmmi.mdsd.math.Binding;
import dk.sdu.mmmi.mdsd.math.Div;
import dk.sdu.mmmi.mdsd.math.Ext;
import dk.sdu.mmmi.mdsd.math.LetBinding;
import dk.sdu.mmmi.mdsd.math.Link;
import dk.sdu.mmmi.mdsd.math.MathExp;
import dk.sdu.mmmi.mdsd.math.MathNumber;
import dk.sdu.mmmi.mdsd.math.MethodName;
import dk.sdu.mmmi.mdsd.math.MethodRefs;
import dk.sdu.mmmi.mdsd.math.MethodSignature;
import dk.sdu.mmmi.mdsd.math.Minus;
import dk.sdu.mmmi.mdsd.math.Mult;
import dk.sdu.mmmi.mdsd.math.Parantheses;
import dk.sdu.mmmi.mdsd.math.Plus;
import dk.sdu.mmmi.mdsd.math.Ref;
import dk.sdu.mmmi.mdsd.math.VarBinding;
import dk.sdu.mmmi.mdsd.math.VarExt;
import dk.sdu.mmmi.mdsd.math.VariableUse;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.StringExtensions;

@SuppressWarnings("all")
public class MathGenerator extends AbstractGenerator {
  private static String top = "//Generated by dasze18";
  
  private static String pkgName = "math_expression";
  
  private static Boolean hasExternal = Boolean.valueOf(false);
  
  private static Map<String, String> varMap;
  
  private static List<Object> list;
  
  private static String str = "";
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    final MathExp x = Iterators.<MathExp>filter(resource.getAllContents(), MathExp.class).next();
    HashMap<String, String> _hashMap = new HashMap<String, String>();
    MathGenerator.varMap = _hashMap;
    ArrayList<Object> _arrayList = new ArrayList<Object>();
    MathGenerator.list = _arrayList;
    EList<Ext> _ext = x.getExt();
    boolean _tripleNotEquals = (_ext != null);
    if (_tripleNotEquals) {
      MathGenerator.hasExternal = Boolean.valueOf(true);
    }
    final Consumer<VarBinding> _function = (VarBinding it) -> {
      this.generateMathFile(x, fsa);
    };
    x.getVariables().forEach(_function);
  }
  
  public void generateMathFile(final MathExp exp, final IFileSystemAccess2 fsa) {
    String name = exp.getProgName();
    fsa.generateFile((((MathGenerator.pkgName + "/") + name) + ".java"), this.generateMath(exp, name));
  }
  
  public CharSequence generateMath(final MathExp exp, final String className) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(MathGenerator.top);
    _builder.newLineIfNotEmpty();
    _builder.append("package ");
    _builder.append(MathGenerator.pkgName);
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("import java.util.*;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("public class ");
    String _firstUpper = StringExtensions.toFirstUpper(className);
    _builder.append(_firstUpper);
    _builder.append(" {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("//Attributes");
    _builder.newLine();
    {
      EList<VarBinding> _variables = exp.getVariables();
      for(final VarBinding m : _variables) {
        CharSequence _generateAttribute = this.generateAttribute(m, exp);
        _builder.append(_generateAttribute);
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    {
      boolean _isEmpty = exp.getExt().isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        _builder.append("private External external;");
        _builder.newLine();
      }
    }
    _builder.newLine();
    _builder.append("    ");
    _builder.newLine();
    _builder.append("//Constructor");
    _builder.newLine();
    CharSequence _addConstructor = MathGenerator.addConstructor(exp, StringExtensions.toFirstUpper(className));
    _builder.append(_addConstructor);
    _builder.append(" ");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("//Compute");
    _builder.newLine();
    CharSequence _addCompute = MathGenerator.addCompute(exp);
    _builder.append(_addCompute);
    _builder.append(" ");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    {
      boolean _isEmpty_1 = exp.getExt().isEmpty();
      boolean _not_1 = (!_isEmpty_1);
      if (_not_1) {
        _builder.append("//Interface");
        _builder.newLine();
        CharSequence _addInterface = MathGenerator.addInterface(exp);
        _builder.append(_addInterface);
        _builder.append(" ");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    _builder.append("}");
    return _builder;
  }
  
  /**
   * --------------
   * HELPER METHODS
   * --------------
   */
  protected CharSequence _generateAttribute(final VarBinding binding, final MathExp exp) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("public int ");
    String _name = binding.getName();
    _builder.append(_name);
    _builder.append(";");
    return _builder;
  }
  
  protected static CharSequence _addConstructor(final MathExp exp, final String className) {
    StringConcatenation _builder = new StringConcatenation();
    {
      boolean _isEmpty = exp.getExt().isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        _builder.append("public ");
        _builder.append(className);
        _builder.append("(External external) { ");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("this.external = external;");
        _builder.newLine();
        _builder.append("}");
        _builder.newLine();
      } else {
        _builder.append("public ");
        _builder.append(className);
        _builder.append("() { \t");
        _builder.newLineIfNotEmpty();
        _builder.append("}");
        _builder.newLine();
      }
    }
    return _builder;
  }
  
  protected static CharSequence _addCompute(final MathExp exp) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("public void compute() {");
    _builder.newLine();
    {
      EList<VarBinding> _variables = exp.getVariables();
      for(final VarBinding num : _variables) {
        _builder.append("    ");
        _builder.append("this.");
        String _name = num.getName();
        _builder.append(_name, "    ");
        _builder.append(" = ");
        String _ExpressionChunk = MathGenerator.ExpressionChunk(num);
        _builder.append(_ExpressionChunk, "    ");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  protected static String _ExpressionChunk(final VarBinding exp) {
    return MathGenerator.ExpressionChunk(exp.getExpression()).toString();
  }
  
  protected static String _ExpressionChunk(final VariableUse exp) {
    return exp.getRef().getName().toString();
  }
  
  protected static String _ExpressionChunk(final VarExt exp) {
    String _xifexpression = null;
    Link _link = exp.getLink();
    EList<Ref> _ref = ((MethodRefs) _link).getRef();
    boolean _tripleNotEquals = (_ref != null);
    if (_tripleNotEquals) {
      String _xblockexpression = null;
      {
        String _name = exp.getName();
        String _plus = ("this.external." + _name);
        String temp = (_plus + "(");
        int count = 0;
        Link _link_1 = exp.getLink();
        EList<Ref> _ref_1 = ((MethodRefs) _link_1).getRef();
        for (final Ref arg : _ref_1) {
          {
            if ((count == 0)) {
              Class<? extends Binding> _class = arg.getRef().getClass();
              String _plus_1 = ("REF" + _class);
              System.out.println(_plus_1);
              String _name_1 = arg.getRef().getName();
              String _plus_2 = (temp + _name_1);
              temp = _plus_2;
            } else {
              String _name_2 = arg.getRef().getName();
              String _plus_3 = ((temp + ",") + _name_2);
              temp = _plus_3;
            }
            int _count = count;
            count = (_count + 1);
            String _name_3 = exp.getName();
            String _plus_4 = ("this.external." + _name_3);
            /* (_plus_4 + "("); */
          }
        }
        _xblockexpression = temp = (temp + ")");
      }
      _xifexpression = _xblockexpression;
    } else {
      String _name = exp.getName();
      String _plus = ("this.external." + _name);
      _xifexpression = (_plus + "()");
    }
    return _xifexpression;
  }
  
  protected static String _ExpressionChunk(final Plus exp) {
    String _ExpressionChunk = MathGenerator.ExpressionChunk(exp.getLeft());
    String _plus = (_ExpressionChunk + " + ");
    String _ExpressionChunk_1 = MathGenerator.ExpressionChunk(exp.getRight());
    return (_plus + _ExpressionChunk_1);
  }
  
  protected static String _ExpressionChunk(final Minus exp) {
    String _ExpressionChunk = MathGenerator.ExpressionChunk(exp.getLeft());
    String _plus = (_ExpressionChunk + " - ");
    String _ExpressionChunk_1 = MathGenerator.ExpressionChunk(exp.getRight());
    return (_plus + _ExpressionChunk_1);
  }
  
  protected static String _ExpressionChunk(final Mult exp) {
    Object _ExpressionChunk = MathGenerator.ExpressionChunk(exp.getLeft());
    String _plus = (_ExpressionChunk + " * ");
    Object _ExpressionChunk_1 = MathGenerator.ExpressionChunk(exp.getRight());
    return (_plus + _ExpressionChunk_1);
  }
  
  protected static String _ExpressionChunk(final Div exp) {
    Object _ExpressionChunk = MathGenerator.ExpressionChunk(exp.getLeft());
    String _plus = (_ExpressionChunk + " / ");
    Object _ExpressionChunk_1 = MathGenerator.ExpressionChunk(exp.getRight());
    return (_plus + _ExpressionChunk_1);
  }
  
  protected static String _ExpressionChunk(final Parantheses exp) {
    String _ExpressionChunk = MathGenerator.ExpressionChunk(exp.getP());
    String _plus = ("(" + _ExpressionChunk);
    return (_plus + ")");
  }
  
  protected static String _ExpressionChunk(final MathNumber exp) {
    return Integer.valueOf(exp.getValue()).toString();
  }
  
  protected static String _ExpressionChunk(final LetBinding exp) {
    return MathGenerator.ExpressionChunk(exp.getBinding());
  }
  
  protected static String _ExpressionBinding(final LetBinding binding) {
    return MathGenerator.ExpressionChunk(binding.getBody());
  }
  
  protected static CharSequence _addInterface(final MathExp exp) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("interface External { ");
    _builder.newLine();
    {
      EList<Ext> _ext = exp.getExt();
      for(final Ext xt : _ext) {
        _builder.append("    ");
        String _xifexpression = null;
        MethodName _name = xt.getName();
        boolean _containsKey = MathGenerator.varMap.containsKey(((MethodName) _name).getName().toString());
        boolean _tripleEquals = (Boolean.valueOf(_containsKey) == Boolean.valueOf(false));
        if (_tripleEquals) {
          String _xblockexpression = null;
          {
            MethodName _name_1 = xt.getName();
            String _name_2 = ((MethodName) _name_1).getName();
            String _plus = ("public int " + _name_2);
            String str = (_plus + "(");
            MethodName _name_3 = xt.getName();
            MethodSignature _sig = ((MethodName) _name_3).getSig();
            boolean _isEmpty = ((Args) _sig).getName().isEmpty();
            if (_isEmpty) {
              str = (str + ");");
            } else {
              int count = 0;
              MethodName _name_4 = xt.getName();
              MethodSignature _sig_1 = ((MethodName) _name_4).getSig();
              EList<String> _name_5 = ((Args) _sig_1).getName();
              for (final String s : _name_5) {
                {
                  if ((count == 0)) {
                    str = (((str + s) + " arg") + Integer.valueOf(count));
                  } else {
                    str = ((((str + ",") + s) + " arg") + Integer.valueOf(count));
                  }
                  int _count = count;
                  count = (_count + 1);
                }
              }
              str = (str + ");");
            }
            MathGenerator.list.add(str);
            MethodName _name_6 = xt.getName();
            _xblockexpression = MathGenerator.varMap.put(((MethodName) _name_6).getName().toString(), "used");
          }
          _xifexpression = _xblockexpression;
        }
        _builder.append(_xifexpression, "    ");
        _builder.newLineIfNotEmpty();
      }
    }
    {
      for(final Object item : MathGenerator.list) {
        _builder.append("    ");
        _builder.append(item, "    ");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("}");
    return _builder;
  }
  
  public CharSequence generateAttribute(final VarBinding binding, final MathExp exp) {
    return _generateAttribute(binding, exp);
  }
  
  public static CharSequence addConstructor(final MathExp exp, final String className) {
    return _addConstructor(exp, className);
  }
  
  public static CharSequence addCompute(final MathExp exp) {
    return _addCompute(exp);
  }
  
  public static String ExpressionChunk(final EObject exp) {
    if (exp instanceof Div) {
      return _ExpressionChunk((Div)exp);
    } else if (exp instanceof LetBinding) {
      return _ExpressionChunk((LetBinding)exp);
    } else if (exp instanceof MathNumber) {
      return _ExpressionChunk((MathNumber)exp);
    } else if (exp instanceof Minus) {
      return _ExpressionChunk((Minus)exp);
    } else if (exp instanceof Mult) {
      return _ExpressionChunk((Mult)exp);
    } else if (exp instanceof Parantheses) {
      return _ExpressionChunk((Parantheses)exp);
    } else if (exp instanceof Plus) {
      return _ExpressionChunk((Plus)exp);
    } else if (exp instanceof VarBinding) {
      return _ExpressionChunk((VarBinding)exp);
    } else if (exp instanceof VariableUse) {
      return _ExpressionChunk((VariableUse)exp);
    } else if (exp instanceof VarExt) {
      return _ExpressionChunk((VarExt)exp);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(exp).toString());
    }
  }
  
  public static String ExpressionBinding(final LetBinding binding) {
    return _ExpressionBinding(binding);
  }
  
  public static CharSequence addInterface(final MathExp exp) {
    return _addInterface(exp);
  }
}
